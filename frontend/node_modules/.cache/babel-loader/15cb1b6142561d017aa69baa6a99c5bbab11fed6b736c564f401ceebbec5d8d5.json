{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useState } from \"react\";\nconst useQueue = () => {\n  _s();\n  const [socket, setSocket] = useState(null);\n  const [queue, setQueue] = useState([]);\n  useEffect(() => {\n    // Create a new WebSocket connection when the component mounts\n    const newSocket = new WebSocket(\"ws://localhost:8000/api/ws\");\n\n    // Event handler when the WebSocket connection is opened\n    newSocket.onopen = () => {\n      console.log(\"WebSocket connected\");\n    };\n\n    // Event handler for received messages\n    newSocket.onmessage = event => {\n      if (newSocket.readyState === WebSocket.OPEN) {\n        setQueue(JSON.parse(event.data));\n      }\n    };\n\n    // Event handler when the WebSocket connection is closed\n    newSocket.onclose = () => {\n      console.log(\"WebSocket closed\");\n    };\n\n    // Set the WebSocket instance in the component's state\n    setSocket(newSocket);\n\n    // Cleanup: Close the WebSocket connection when the component is unmounted\n    return () => {\n      newSocket.close();\n    };\n  }, []); // The empty dependency array ensures that this effect runs only once on mount\n\n  // Expose the socket and queue state to the components using this hook\n  return {\n    queue\n  };\n};\n_s(useQueue, \"PAltc5hdmrZ1PaMoYeO/9fkHy0Y=\");\nexport default useQueue;","map":{"version":3,"names":["useEffect","useState","useQueue","_s","socket","setSocket","queue","setQueue","newSocket","WebSocket","onopen","console","log","onmessage","event","readyState","OPEN","JSON","parse","data","onclose","close"],"sources":["/Users/alexkeith/encodarr/frontend/src/hooks/useQueue.ts"],"sourcesContent":["import { useEffect, useState } from \"react\";\n\nconst useQueue = () => {\n\tconst [socket, setSocket] = useState(null);\n\tconst [queue, setQueue] = useState([]);\n\n\tuseEffect(() => {\n\t\t// Create a new WebSocket connection when the component mounts\n\t\tconst newSocket: any = new WebSocket(\"ws://localhost:8000/api/ws\");\n\n\t\t// Event handler when the WebSocket connection is opened\n\t\tnewSocket.onopen = () => {\n\t\t\tconsole.log(\"WebSocket connected\");\n\t\t};\n\n\t\t// Event handler for received messages\n\t\tnewSocket.onmessage = (event: any) => {\n\t\t\tif (newSocket.readyState === WebSocket.OPEN) {\n\t\t\t\tsetQueue(JSON.parse(event.data));\n\t\t\t}\n\t\t};\n\n\t\t// Event handler when the WebSocket connection is closed\n\t\tnewSocket.onclose = () => {\n\t\t\tconsole.log(\"WebSocket closed\");\n\t\t};\n\n\t\t// Set the WebSocket instance in the component's state\n\t\tsetSocket(newSocket);\n\n\t\t// Cleanup: Close the WebSocket connection when the component is unmounted\n\t\treturn () => {\n\t\t\tnewSocket.close();\n\t\t};\n\t}, []); // The empty dependency array ensures that this effect runs only once on mount\n\n\t// Expose the socket and queue state to the components using this hook\n\treturn { queue };\n};\n\nexport default useQueue;\n"],"mappings":";AAAA,SAASA,SAAS,EAAEC,QAAQ,QAAQ,OAAO;AAE3C,MAAMC,QAAQ,GAAGA,CAAA,KAAM;EAAAC,EAAA;EACtB,MAAM,CAACC,MAAM,EAAEC,SAAS,CAAC,GAAGJ,QAAQ,CAAC,IAAI,CAAC;EAC1C,MAAM,CAACK,KAAK,EAAEC,QAAQ,CAAC,GAAGN,QAAQ,CAAC,EAAE,CAAC;EAEtCD,SAAS,CAAC,MAAM;IACf;IACA,MAAMQ,SAAc,GAAG,IAAIC,SAAS,CAAC,4BAA4B,CAAC;;IAElE;IACAD,SAAS,CAACE,MAAM,GAAG,MAAM;MACxBC,OAAO,CAACC,GAAG,CAAC,qBAAqB,CAAC;IACnC,CAAC;;IAED;IACAJ,SAAS,CAACK,SAAS,GAAIC,KAAU,IAAK;MACrC,IAAIN,SAAS,CAACO,UAAU,KAAKN,SAAS,CAACO,IAAI,EAAE;QAC5CT,QAAQ,CAACU,IAAI,CAACC,KAAK,CAACJ,KAAK,CAACK,IAAI,CAAC,CAAC;MACjC;IACD,CAAC;;IAED;IACAX,SAAS,CAACY,OAAO,GAAG,MAAM;MACzBT,OAAO,CAACC,GAAG,CAAC,kBAAkB,CAAC;IAChC,CAAC;;IAED;IACAP,SAAS,CAACG,SAAS,CAAC;;IAEpB;IACA,OAAO,MAAM;MACZA,SAAS,CAACa,KAAK,CAAC,CAAC;IAClB,CAAC;EACF,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;;EAER;EACA,OAAO;IAAEf;EAAM,CAAC;AACjB,CAAC;AAACH,EAAA,CApCID,QAAQ;AAsCd,eAAeA,QAAQ"},"metadata":{},"sourceType":"module","externalDependencies":[]}