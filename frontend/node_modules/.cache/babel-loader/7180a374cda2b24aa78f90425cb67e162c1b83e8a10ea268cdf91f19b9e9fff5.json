{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useState } from \"react\";\nconst useHistory = () => {\n  _s();\n  const [socket, setSocket] = useState(null);\n  const [history, setHistory] = useState([]);\n  useEffect(() => {\n    // Create a new WebSocket connection when the component mounts\n    const newSocket = new WebSocket(\"ws://localhost:8000/ws\");\n\n    // Event handler when the WebSocket connection is opened\n    newSocket.onopen = () => {\n      console.log(\"WebSocket connected\");\n    };\n\n    // Event handler for received messages\n    newSocket.onmessage = event => {\n      if (newSocket.readyState === WebSocket.OPEN) {\n        setHistory(JSON.parse(event.data));\n      }\n    };\n\n    // Event handler when the WebSocket connection is closed\n    newSocket.onclose = () => {\n      console.log(\"WebSocket closed\");\n    };\n\n    // Set the WebSocket instance in the component's state\n    setSocket(newSocket);\n\n    // Cleanup: Close the WebSocket connection when the component is unmounted\n    return () => {\n      newSocket.close();\n    };\n  }, []); // The empty dependency array ensures that this effect runs only once on mount\n\n  // Expose the socket and queue state to the components using this hook\n  return history;\n};\n_s(useHistory, \"VSiFSAEsOKqanhIVyrHbcbR/woc=\");\nexport default useHistory;","map":{"version":3,"names":["useEffect","useState","useHistory","_s","socket","setSocket","history","setHistory","newSocket","WebSocket","onopen","console","log","onmessage","event","readyState","OPEN","JSON","parse","data","onclose","close"],"sources":["/Users/alexkeith/encodarr/src/hooks/useHistory.ts"],"sourcesContent":["import { useEffect, useState } from \"react\";\n\nconst useHistory = () => {\n\tconst [socket, setSocket] = useState(null);\n\tconst [history, setHistory] = useState([]);\n\n\tuseEffect(() => {\n\t\t// Create a new WebSocket connection when the component mounts\n\t\tconst newSocket: any = new WebSocket(\"ws://localhost:8000/ws\");\n\n\t\t// Event handler when the WebSocket connection is opened\n\t\tnewSocket.onopen = () => {\n\t\t\tconsole.log(\"WebSocket connected\");\n\t\t};\n\n\t\t// Event handler for received messages\n\t\tnewSocket.onmessage = (event: any) => {\n\t\t\tif (newSocket.readyState === WebSocket.OPEN) {\n\t\t\t\tsetHistory(JSON.parse(event.data));\n\t\t\t}\n\t\t};\n\n\t\t// Event handler when the WebSocket connection is closed\n\t\tnewSocket.onclose = () => {\n\t\t\tconsole.log(\"WebSocket closed\");\n\t\t};\n\n\t\t// Set the WebSocket instance in the component's state\n\t\tsetSocket(newSocket);\n\n\t\t// Cleanup: Close the WebSocket connection when the component is unmounted\n\t\treturn () => {\n\t\t\tnewSocket.close();\n\t\t};\n\t}, []); // The empty dependency array ensures that this effect runs only once on mount\n\n\t// Expose the socket and queue state to the components using this hook\n\treturn history;\n};\n\nexport default useHistory;\n"],"mappings":";AAAA,SAASA,SAAS,EAAEC,QAAQ,QAAQ,OAAO;AAE3C,MAAMC,UAAU,GAAGA,CAAA,KAAM;EAAAC,EAAA;EACxB,MAAM,CAACC,MAAM,EAAEC,SAAS,CAAC,GAAGJ,QAAQ,CAAC,IAAI,CAAC;EAC1C,MAAM,CAACK,OAAO,EAAEC,UAAU,CAAC,GAAGN,QAAQ,CAAC,EAAE,CAAC;EAE1CD,SAAS,CAAC,MAAM;IACf;IACA,MAAMQ,SAAc,GAAG,IAAIC,SAAS,CAAC,wBAAwB,CAAC;;IAE9D;IACAD,SAAS,CAACE,MAAM,GAAG,MAAM;MACxBC,OAAO,CAACC,GAAG,CAAC,qBAAqB,CAAC;IACnC,CAAC;;IAED;IACAJ,SAAS,CAACK,SAAS,GAAIC,KAAU,IAAK;MACrC,IAAIN,SAAS,CAACO,UAAU,KAAKN,SAAS,CAACO,IAAI,EAAE;QAC5CT,UAAU,CAACU,IAAI,CAACC,KAAK,CAACJ,KAAK,CAACK,IAAI,CAAC,CAAC;MACnC;IACD,CAAC;;IAED;IACAX,SAAS,CAACY,OAAO,GAAG,MAAM;MACzBT,OAAO,CAACC,GAAG,CAAC,kBAAkB,CAAC;IAChC,CAAC;;IAED;IACAP,SAAS,CAACG,SAAS,CAAC;;IAEpB;IACA,OAAO,MAAM;MACZA,SAAS,CAACa,KAAK,CAAC,CAAC;IAClB,CAAC;EACF,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;;EAER;EACA,OAAOf,OAAO;AACf,CAAC;AAACH,EAAA,CApCID,UAAU;AAsChB,eAAeA,UAAU"},"metadata":{},"sourceType":"module","externalDependencies":[]}